# Узкие места

## Набор предупреждений и рекомендаций

* Использование в качестве пинов переменные значения уменьшает скорость работы и увеличивает размер выхлопа. Так как требует сопоставлять номер пина с его портом и соответствующему ему битом во время исполнения.
* Nerv регламентирует очень малую часть интерфейса. Большая часть настроек аппаратно зависимая!

## Итерация по массиву с использованием `init_pin` и т.д. 

#### Проблема

Следующий код не с оптимизируется! 

```c
pin_t pins[] = {1, 2, 3};

for (uint8_t i = 0; i < sizeof(pins); i++)
  init_pin(pins[i], OUTPUT);
```

#### Рекомендация 

В данном случае этот вариант будет эффективнее, хоть и куда менее выразительнее. 
```c
init_pin(1, OUTPUT);
init_pin(2, OUTPUT);
init_pin(3, OUTPUT);
```
Поэтому рекомендуется подобрать расположения контактов так, чтобы за них отвечал 
один порт ввода-вывода, что позволит написать следующую конструкцию:
```c
DDRx = bit(PB1) | bit(PB2) | bit(PB3);
```

## Использование функций nerv в ваших функциях 

Функции библиотеки написаны с наседанием на возможности компилятора 
inlining'у и constant evaluation. 

#### Проблема 

Поэтому следующий код не с оптимизируется:
```c
bool some_state;

void your_func(pin_t pin) {
  digital_write(pin, some_state);
}

void _start() {
  while (1) {
    your_func(3);
  }
}
```
Компилятор раскроет выражение, но только в `your_func` и со всеми необходимым 
рантаймом.

#### Рекомендация 

Поэтому рекомендуется держать в голове то, что функции nerv следует использовать 
в функциях с модификатором `inline`:
```c
...
inline void your_func(pin_t pin) {
...
```
Если прошлый вариант занимал целых 167 байт, то новый вариант всего навсего 17. 
